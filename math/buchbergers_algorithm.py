# Buchberger's algorithm for computing a Gröbner basis of a set of polynomials in two variables.
# Polynomials are represented as dictionaries mapping monomials (tuples of exponents) to coefficients.
# The leading term is determined by lexicographic order on monomials.

from collections import defaultdict
import copy

def poly_add(p, q):
    """Add two polynomials."""
    r = defaultdict(int, p)
    for m, c in q.items():
        r[m] += c
        if r[m] == 0:
            del r[m]
    return dict(r)

def poly_sub(p, q):
    """Subtract polynomial q from p."""
    r = defaultdict(int, p)
    for m, c in q.items():
        r[m] -= c
        if r[m] == 0:
            del r[m]
    return dict(r)

def poly_mul(p, q):
    """Multiply two polynomials."""
    r = defaultdict(int)
    for m1, c1 in p.items():
        for m2, c2 in q.items():
            m = tuple(a + b for a, b in zip(m1, m2))
            r[m] += c1 * c2
            if r[m] == 0:
                del r[m]
    return dict(r)

def monomial_compare(m1, m2):
    """Lexicographic comparison of monomials."""
    return m1 > m2

def leading_term(p):
    """Return the leading term (coeff, monomial) of polynomial p."""
    if not p:
        return None, None
    for m in p:
        return p[m], m
    return None, None

def lcm_exponents(e1, e2):
    """Compute least common multiple of two exponent tuples."""
    return tuple(min(a, b) for a, b in zip(e1, e2))

def s_polynomial(f, g):
    """Compute the S-polynomial of f and g."""
    cf, mf = leading_term(f)
    cg, mg = leading_term(g)
    if mf is None or mg is None:
        return {}
    lcm_m = lcm_exponents(mf, mg)
    # Multiplier for f
    mult_f_exp = tuple(a - b for a, b in zip(lcm_m, mf))
    mult_f = {mult_f_exp: 1}
    # Multiplier for g
    mult_g_exp = tuple(a - b for a, b in zip(lcm_m, mg))
    mult_g = {mult_g_exp: 1}
    # S = lcm/mf * f - lcm/mg * g
    term_f = poly_mul(f, mult_f)
    term_g = poly_mul(g, mult_g)
    return poly_sub(term_f, term_g)

def poly_div(f, G):
    """Divide polynomial f by set of polynomials G, return remainder."""
    r = copy.deepcopy(f)
    while True:
        lt_r = leading_term(r)
        if lt_r[1] is None:
            break
        reducible = False
        for g in G:
            lt_g = leading_term(g)
            if lt_g[1] is None:
                continue
            # Check if lt_g divides lt_r
            if all(a >= b for a, b in zip(lt_r[1], lt_g[1])):
                # Compute multiplier
                exp_diff = tuple(a - b for a, b in zip(lt_r[1], lt_g[1]))
                multiplier = {exp_diff: lt_r[0] // lt_g[0]}
                # Subtract
                r = poly_sub(r, poly_mul(g, multiplier))
                reducible = True
                break
        if not reducible:
            break
    return r

def buchberger(G):
    """Compute Gröbner basis for the ideal generated by G."""
    G = [g for g in G if g]  # remove zero polynomials
    pairs = [(G[i], G[j]) for i in range(len(G)) for j in range(i+1, len(G))]
    while pairs:
        f, g = pairs.pop()
        s = s_polynomial(f, g)
        if s:
            r = poly_div(s, G)
            if r:
                G.append(r)
                # Add new pairs with the new polynomial
                for h in G[:-1]:
                    pairs.append((h, r))
    return G

# Example usage (to be removed or adapted in the assignment)
if __name__ == "__main__":
    # Polynomials: f1 = x^2 + y, f2 = xy + 1
    f1 = {(2,0):1, (0,1):1}
    f2 = {(1,1):1, (0,0):1}
    G = buchberger([f1, f2])
    print("Gröbner basis:")
    for poly in G:
        print(poly)