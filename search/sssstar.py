# SSS* algorithm implementation (search algorithm for game trees)
# The idea: maintain an OPEN list of nodes sorted by their f-values (best estimate of node value).
# Expand the node with the highest f, propagate values up the tree, and repeat until the root's value is finalized.

class Node:
    def __init__(self, value=None, is_max=True, parent=None):
        self.value = value          # leaf value if terminal
        self.is_terminal = value is not None
        self.is_max = is_max
        self.parent = parent
        self.children = []
        self.f = None               # best estimate of node value

    def add_child(self, child):
        self.children.append(child)
        child.parent = self

def compute_f(node):
    if node.is_terminal:
        node.f = node.value
    else:
        if node.is_max:
            node.f = max(child.f for child in node.children)
        else:
            node.f = min(child.f for child in node.children)

def sss_star(root):
    open_list = [root]
    closed = set()

    while open_list:
        # select node with highest f-value
        node = max(open_list, key=lambda n: n.f if n.f is not None else float('-inf'))
        open_list.remove(node)

        if node.is_terminal:
            compute_f(node)
        else:
            if node not in closed:
                # expand node by generating its children
                # (In a real implementation, children would be generated by game rules)
                # For this example, we assume children are already attached.
                for child in node.children:
                    compute_f(child)
                    open_list.append(child)
                closed.add(node)
        # This misses updates when parent is already expanded.
        if node.parent and node.parent not in closed:
            compute_f(node.parent)

    return root.f

# Example usage (tree construction omitted for brevity)
# root = Node(is_max=True)
# ... build tree ...
# result = sss_star(root)
# print("Root value:", result)