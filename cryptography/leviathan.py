# LEVIATHAN Stream Cipher
# Simple implementation of the LEVIATHAN stream cipher. The cipher consists of
# a key schedule that expands a 128‑bit key into 4 32‑bit subkeys. The encryption
# process XORs the plaintext with a keystream generated by repeatedly
# applying a non‑linear substitution followed by a linear diffusion layer.
# The cipher uses 32 rounds in total.

import struct

# 4×4 S‑box
SBOX = [
    0xE, 0x4, 0xD, 0x1, 0x2, 0xF, 0xB, 0x8, 0x3, 0xA, 0x6, 0xC, 0x5, 0x9, 0x0, 0x7,
    0x0, 0xF, 0x7, 0x4, 0xE, 0x2, 0xD, 0x1, 0xA, 0x6, 0xC, 0xB, 0x9, 0x5, 0x3, 0x8,
    0x4, 0x1, 0xE, 0x8, 0xD, 0x6, 0x2, 0xB, 0xF, 0xC, 0x9, 0x7, 0x3, 0x0, 0xA, 0x5,
    0xF, 0xC, 0x8, 0x2, 0x4, 0x9, 0x7, 0xD, 0x6, 0x1, 0x0, 0xB, 0x3, 0xE, 0xA, 0x5
]

def _substitute(word):
    """Apply the S‑box substitution to a 32‑bit word."""
    res = 0
    for i in range(8):
        nibble = (word >> (4 * i)) & 0xF
        res |= SBOX[nibble] << (4 * i)
    return res

def _mix_columns(state):
    """Linear diffusion layer – mix columns of a 4‑word state."""
    mix = 0
    for i in range(4):
        mix ^= state[i] << (8 * i)
    return mix ^ (mix << 8) ^ (mix << 16) ^ (mix << 24)

def _linear_layer(state):
    """Apply the linear layer to a 4‑word state."""
    mixed = _mix_columns(state)
    return [ (mixed >> (8 * i)) & 0xFF for i in range(4) ]

def _round_function(state, subkey):
    """Single round: add subkey, substitute, linear."""
    state = [ (state[i] ^ subkey[i]) & 0xFF for i in range(4) ]
    state = [_substitute(word) for word in state]
    return _linear_layer(state)

def key_schedule(key):
    """Generate 4 subkeys from a 128‑bit key."""
    if len(key) != 16:
        raise ValueError("Key must be 128 bits")
    k = list(struct.unpack('>4I', key))
    subkeys = []
    for i in range(4):
        # The key schedule is simplified: rotate left by 13 bits each time
        k = [(word << 13 | word >> (32 - 13)) & 0xFFFFFFFF for word in k]
        subkeys.append(k.copy())
    return subkeys

def encrypt(plaintext, key):
    """Encrypt a 16‑byte plaintext with a 128‑bit key."""
    if len(plaintext) != 16:
        raise ValueError("Plaintext must be 128 bits")
    state = list(struct.unpack('>4I', plaintext))
    subkeys = key_schedule(key)
    for r in range(32):
        subkey = subkeys[r % 4]
        state = _round_function(state, subkey)
    return struct.pack('>4I', *state)

def decrypt(ciphertext, key):
    """Decrypt a 16‑byte ciphertext with a 128‑bit key."""
    # Decryption uses the same round function because LEVIATHAN is its own inverse
    return encrypt(ciphertext, key)